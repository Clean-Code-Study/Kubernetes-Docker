# 3장. 컨테이너를 다루는 표준 아키첵처, 쿠버네티스

컨테이너 인프라 환경 : 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경

- 기업 환경에서는 다수의 관리자가 수백 또는 수천 대의 서버를 함께 관리하기 때문에 일관성을 유지하는 것이 매우 중요함. → 눈송이 서버(여러 사람이 만져서 설정의 일관성이 떨어진 서버)를 방지하는 데 효과적임.
- 운영 체제 커널 하나에 컨테이너 여러 개가 격리된 형태로 실행되기 때문에 자원을 효율적을 사용할 수 있고, 거치는 단계가 적어서 속도도 훨씬 빠름.

# 3.1. 쿠버네티스 이해하기

쿠버네티스는 컨테이너 오케스트레이션을 위한 솔루션임.

오케이스레이션

- 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽세 사용하도록 서비스를 제공
- 다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어줌.

## 1. 왜 쿠버네티스일까

- 도커 스웜(Docker Swarm)
  - 소규모 환경에서 유용하지만 대규모 환경에서는 잘 사용하지 않음.
  - 장점
    - 간단하게 설치 가능
    - 사용하기 용이
  - 단점
    - 기능이 다양하지 않음. → 대규모 환경에 적용하려면 사용자 환경을 변경해야 할 수 있음.
- 메소스(Mesos)
  - 장점
    - 검증됨.
    - 매우 간결함.
  - 단점
    - 기능을 충분히 활용하려면 분산 관리 시스템과 연동해야 함. → 여러 가지 솔루션을 유기적으로 구성해야 하는 부담이 있음.
- 노메드(Nomad)
  - 가볍고 간단한 기능만 필요한 환경에서 사용하기를 권장함.
  - 장점
    - 간단한 구성으로 컨테이너 오케스트레이션 환경을 제공함.
    - Consul과 Valut와의 연동이 원할함.
  - 단점
    - 기능이 부족함.
- 쿠버네티스
  - 장점
    - 쉽게 사용할 수 있도록 도와주는 도구들이 있어서 설치가 쉬워지는 추세임.
    - 거의 모든 벤더와 오픈 소스 진영 모두에서 쿠버네티스를 지원하고 그에 맞게 통합 개발하고 있음.
  - 단점
    - 시작하는데 어려움이 있음.

## 2. 쿠버네티스 구성 방법

- 관리형 쿠버네티스
  - 퍼블릭 클라우드 업체에서 제공
  - 구성이 이미 다 갖춰져 있고, 마스터 노드를 클라우드 업체에서 관리함.
  - 예시
    - EKS (Amazon)
    - AKS (Azure)
    - GKE (Google)
- 설치형 쿠버네티스
  - 플랫폼 업체에서 제공
  - 유료
  - 예시
    - Rancher (수세)
    - OpenShift (래드햇)
- 구성형 쿠버네티스
  - 사용하는 시스템에 쿠버네티스 클러스터를 자동으로 구성해주는 솔루션
  - 예시
    - kubeadm : 가장 널리 알려져 있음.
      - 사용자가 변경하기 수월함.
      - 온프레미스와 클라우드 모두 지원함.
      - 배우기 쉬움.
    - kops
    - KRIB
    - kubespray

## 3. 쿠버네티스 구성하기

<https://github.com/sysnet4admin/_Book_k8sInfra/tree/main/ch3/3.1.3>

```bash
# bash
vagrant up # 쿠버네티스 테스트 환경 구성하기

ssh root@192.168.1.10 # m-k8s 터미널 접속

# m-k8s 터미널
kubectl get nodes # 쿠버네티스 클러스터에 마스터 노드와 워커 노드들이 정상적으로 생성되고 연결되었는지 확인하기
```

## 4. 파드 배포를 중심으로 쿠버네티스 구성 요소 살펴보기

### 관리자나 개발자가 파드를 배포할 때 실행되는 순서

마스터 노드

0. kubectl
   - 쿠버네티스 클러스터에 명령을 내리는 역할
   - 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 바이너리로 배포되기 때문에 마스터 노드에 있을 필요는 없음.
1. API 서버
   - 쿠버네티스 클러스터의 중심 역할을 하는 통로
   - 줄 상태 값을 저장하는 `etcd`와 통신하지만, 그 밖의 요소들 또한 API 서버를 중심에 두고 통신함.
2. etcd
   - 구성 요소들의 상태 값이 모두 저장되는 곳
   - etcd의 정보만 백업돼 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스는 복구할 수 있음.
   - 분산 저장이 가능한 key-value 저장소이므로, 복제해 여러 곳에 두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있음.
3. 컨트롤러 매니저
   - 쿠버네티스 클러스터의 오브젝트 상태를 관리
   - 다양한 상태 값을 관리하는 주체들이 컨트롤러 매니저에 소속돼 각자의 역할을 수행함.
     - 노드 컨트롤러 : 워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구
     - 레플리카셋 컨트롤러 : 요청받은 파드 개수대로 파드를 생성
     - 엔드 포인트 컨트롤러 : 서비스와 파드를 연결
4. 스케줄러
   - 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당
   - 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리

워커 노드

5. kubelet
   - 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링함.
6. 컨테이너 런타임
   - 파드를 이루는 컨테이너의 실행을 담당
   - 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스
7. 파드
   - 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위
   - 언제라도 죽을 수 있는 존재

선택적으로 배포하는 것들

- 네트워크 플러그인
  - 쿠버네티스 클러스터의 통신을 위해서 네트워크 플러그인을 선택하고 구성해야 함.
  - 일반적으로 CNI로 구성함.
- CoreDNS
  - 빠르고 유연한 DNS 서버
  - 쿠버네티스 클러스터에서 도메인 이름을 이용해 통신하는데 사용함.
  - 쿠버네티스 클러스터를 구성하여 사용할 때는 IP보다 도메인 네임을 편리하게 관리해주는 CoreDNS를 사용하는 것이 일반적임.

### 사용자가 배포된 파드에 접속할 때

1. kube-proxy
   - 쿠버네티스 클러스터는 파드가 위치한 노드에 kube-proxy를 통해 파드가 통신할 수 있는 네트워크를 설정함.
2. 파드
   - 이미 배포된 파드에 접속하고 필요한 내용을 전달받음.
   - 대부분의 사용자는 파드가 어느 워커 노드에 위치하는지 신경쓰지 않아도 됨.

## 5. 파드의 생명주기로 쿠버네티스 구성 요소 살펴보기

쿠버네티스의 가장 큰 장점은 쿠버네티스의 구성 요소마다 하는 일이 명확하게 구분돼 각자의 역할만 충실하게 수행하면 클러스터 시스템이 안정적으로 운영된다는 점이다. (MSA 구조와 유사)

또한 역할이 나뉘어 있어서 문제가 발생했을 때 어느 부분에서 문제가 발생했는지 디버깅하기 쉽다.

### 파드의 생명주기

1. kubectl을 통해 API 서버에 파드 생성을 요청한다.
2. (업데이트가 있을 때마다 매번) API 서버에 전달된 내용이 있으면 API 서버는 etcd에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지한다. 따라서 각 요소가 상태를 업데이트할 때마다 모두 API 서버를 통해 etcd에 기록된다.
3. 컨트롤러 매니저가 API 서버에 파드 생성이 요청된 것을 인지하면, 컨트롤러 매니저는 파드를 생성하고, 이 상태를 API 서버에 전달한다. 아직 어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태로 파드만 생성된다.
4. 스케줄러가 API 서버에 파드가 생성됐다는 정보를 인지하면, 생성된 파드를 어떤 워커 노드에 적용할지 조건을 고려해 결정하고 해당 워커 노드에 파드를 띄우도록 요청한다.
5. 스케줄러가 API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해 있는지 kubelet으로 확인한다.
6. kubelet에서 컨테이너 런타임으로 파드 생성을 요청한다.
7. 파드가 생성된다.
8. 파드가 사용 가능한 상태가 된다.

### 쿠버네티스의 구조

쿠버네티스는 작업을 순서대로 진행하는 워크플로 구조가 아니라 **선언적인 시스템 구조**를 가지고 있다. 즉, 각 요소가 추구하는 상태를 선언하면 현재 상태와 맞는지 점검하고 그것에 맞추려고 노력하는 구조로 돼 있다. 따라서 추구하는 상태를 API 서버에 선언하면 다른 요소들이 API 서버에 와서 현재 상태와 비교하고 그에 맞게 상태를 변경하려고 한다. 여기서 API는 현재 상태 값을 가지고 있는데, 이것을 보존해야 해서 etcd가 필요하다.

워커 노드는 워크플로 구조에 따라 설계됐다. kubelet과 컨테이너 런타임을 통해 파드를 생성하고 제거해야 하는 구조여서 선언적인 방식으로 구조화하기에는 어려움이 있기 때문이다. 또한, 명령이 절차적으로 전달되는 방식은 시스템의 성능을 높이는 데 효율적이다.

마스터 노드는 이미 생성된 파드들을 유기적으로 연결하므로 쿠버네티스 클러스터를 안정적으로 유지하려면 선언적인 시스템이 더 낫다.

## 6. 쿠버네티스 구성 요소의 기능 검증하기

### kubectl 을 실행하기 위해 필요한 것 확인하기

```shell
ssh root@127.0.0.1 -p 60103

# w3-k8s
kubectl get nodes # 오류

scp root@192.168.1.10:/etc/kubernetes/admin.conf . # 192.168.1.10(마스터 노드)에서 scp(secure copy) 명령으로 쿠버네티스 클러스터 정보(/etc/kubernetes/admin.conf)를 현재 디렉토리(.)로 받아온다.

kubectl get nodes --kubeconfig admin.conf # 쿠버네티스 클러스터 정보를 입력받는 옵션(--kubeconfig)으로 마스터 노드에서 받아온 admin.conf 를 입력받아 실행한다.
```

### kubelet 역할 확인하기

kubelet은 쿠버네티스에서 파드의 생성과 상태 관리 및 복구 등을 담당하는 매우 중요한 구성 요소이다. kubelet에 문제가 생기면 파드가 정상적으로 관리되지 않는다.

```shell
# m-k8s
kubectl create -f ~/_Book_k8sInfra/ch3/3.1.6/nginx-pod.yaml # nginx-pod 파드 배포하기

kubectl get pod # 생성된 파드 확인하기

kubectl get pod -o wide # 어느 노드에 파드가 배포되었는지 확인하기

# 워커 노드 (위에서 확인한 노드에 접속하기)
systemctl stop kubelet # kubelet 중지하기

# 마스터 노드
kubectl delete pod nginx-pod # nginx-pod 삭제하기 -> 위의 노드에서 kubelet을 중지했기 때문에 삭제되지 않는다. -> Ctrl + C 로 중지하기

kubectl get pod # STATUS가 Terminating 상태로 파드는 삭제되지 않는다.

# 워커 노드 (kubelet을 중지한 노드에 다시 접속하기)
systemctl start kubelet # kubelet 시작하기

# 마스터 노드
kubectl get pod # 잠시후에 파드가 삭제된 것을 확인할 수 있다.
```

### kube-proxy 역할 확인하기

kube-proxy는 파드의 통신을 담당한다.

```shell
# 마스터 노드
kubectl create -f ~/_Book_k8sInfra/ch3/3.1.6/nginx-pod.yaml # nginx-pod 파드 배포하기

kubectl get pod -o wide # 파드의 IP와 워커 노드 확인하기

curl 172.16.132.3 # 172.16.132.3 : 위에서 생성된 파드의 IP 주소

# 워커 노드
modprobe -r br_netfilter # br_netfilter 모듈 제거하기
systemctl restart network # 변경된 내용 적용을 위해 네트워크 다시 시작하기

# 마스터 노드
kubectl get pod -o wide # Running 상태이지만 통신이 되지 않음.

# 워커 노드
modprobe br_netfilter # br_netfilter를 커널에 적재하기
reboot # 시스템 다시 시작하여 적용하기

# 마스터 노드
kubectl get pod -o wide # 일정시간이 지난 후에 RESTART가 1 증가하고, IP 주소가 변경된 것을 확인할 수 있다.
```
